// The purpose of this code is to fix the height of overflow: auto blocks, because some browsers can't figure it out for themselves.function smf_codeBoxFix() {    var codeFix = document.getElementsByTagName('code');    for (var i = codeFix.length - 1; i >= 0; i--) {        if (is_webkit && codeFix[i].offsetHeight < 20)            codeFix[i].style.height = (codeFix[i].offsetHeight + 20) + 'px';        else if (is_ff && (codeFix[i].scrollWidth > codeFix[i].clientWidth || codeFix[i].clientWidth == 0))            codeFix[i].style.overflow = 'scroll';        else if ('currentStyle' in codeFix[i] && codeFix[i].currentStyle.overflow == 'auto' && (codeFix[i].currentStyle.height == '' || codeFix[i].currentStyle.height == 'auto') && (codeFix[i].scrollWidth > codeFix[i].clientWidth || codeFix[i].clientWidth == 0) && (codeFix[i].offsetHeight != 0))            codeFix[i].style.height = (codeFix[i].offsetHeight + 24) + 'px';    }}// Add a fix for code stuff?if ((is_ie && !is_ie4) || is_webkit || is_ff)    addLoadEvent(smf_codeBoxFix);// Toggles the element height and width styles of an image.function smc_toggleImageDimensions() {    var oImages = document.getElementsByTagName('IMG');    for (oImage in oImages) {        // Not a resized image? Skip it.        if (oImages[oImage].className == undefined || oImages[oImage].className.indexOf('bbc_img resized') == -1)            continue;        oImages[oImage].style.cursor = 'pointer';        oImages[oImage].onclick = function () {            this.style.width = this.style.height = this.style.width == 'auto' ? null : 'auto';        };    }}// Add a load event for the function above.addLoadEvent(smc_toggleImageDimensions);// Adds a button to a certain button strip.function smf_addButton(sButtonStripId, bUseImage, oOptions) {    var oButtonStrip = document.getElementById(sButtonStripId);    var aItems = oButtonStrip.getElementsByTagName('span');    // Remove the 'last' class from the last item.    if (aItems.length > 0) {        var oLastSpan = aItems[aItems.length - 1];        oLastSpan.className = oLastSpan.className.replace(/\s*last/, 'position_holder');    }    // Add the button.    var oButtonStripList = oButtonStrip.getElementsByTagName('ul')[0];    var oNewButton = document.createElement('li');    setInnerHTML(oNewButton, '<a href="' + oOptions.sUrl + '" ' + ('sCustom' in oOptions ? oOptions.sCustom : '') + '><span class="last"' + ('sId' in oOptions ? ' id="' + oOptions.sId + '"' : '') + '>' + oOptions.sText + '</span></a>');    oButtonStripList.appendChild(oNewButton);}// Adds hover events to list items. Used for a versions of IE that don't support this by default.var smf_addListItemHoverEvents = function () {    var cssRule, newSelector;    // Add a rule for the list item hover event to every stylesheet.    for (var iStyleSheet = 0; iStyleSheet < document.styleSheets.length; iStyleSheet++)        for (var iRule = 0; iRule < document.styleSheets[iStyleSheet].rules.length; iRule++) {            oCssRule = document.styleSheets[iStyleSheet].rules[iRule];            if (oCssRule.selectorText.indexOf('LI:hover') != -1) {                sNewSelector = oCssRule.selectorText.replace(/LI:hover/gi, 'LI.iehover');                document.styleSheets[iStyleSheet].addRule(sNewSelector, oCssRule.style.cssText);            }        }    // Now add handling for these hover events.    var oListItems = document.getElementsByTagName('LI');    for (oListItem in oListItems) {        oListItems[oListItem].onmouseover = function () {            this.className += ' iehover';        };        oListItems[oListItem].onmouseout = function () {            this.className = this.className.replace(new RegExp(' iehover\\b'), '');        };    }}// Add hover events to list items if the browser requires it.if (is_ie7down && 'attachEvent' in window)    window.attachEvent('onload', smf_addListItemHoverEvents);(function ($) {    $.fn.hoverIntent = function (f, g) {        // default configuration options        var cfg = {            sensitivity: 7,            interval: 100,            timeout: 0        };        // override configuration options with user supplied object        cfg = $.extend(cfg, g ? {over: f, out: g} : f);        // instantiate variables        // cX, cY = current X and Y position of mouse, updated by mousemove event        // pX, pY = previous X and Y position of mouse, set by mouseover and polling interval        var cX, cY, pX, pY;        // A private function for getting mouse position        var track = function (ev) {            cX = ev.pageX;            cY = ev.pageY;        };        // A private function for comparing current and previous mouse position        var compare = function (ev, ob) {            ob.hoverIntent_t = clearTimeout(ob.hoverIntent_t);            // compare mouse positions to see if they've crossed the threshold            if ((Math.abs(pX - cX) + Math.abs(pY - cY)) < cfg.sensitivity) {                $(ob).unbind("mousemove", track);                // set hoverIntent state to true (so mouseOut can be called)                ob.hoverIntent_s = 1;                return cfg.over.apply(ob, [ev]);            } else {                // set previous coordinates for next time                pX = cX;                pY = cY;                // use self-calling timeout, guarantees intervals are spaced out properly (avoids JavaScript timer bugs)                ob.hoverIntent_t = setTimeout(function () {                    compare(ev, ob);                }, cfg.interval);            }        };        // A private function for delaying the mouseOut function        var delay = function (ev, ob) {            ob.hoverIntent_t = clearTimeout(ob.hoverIntent_t);            ob.hoverIntent_s = 0;            return cfg.out.apply(ob, [ev]);        };        // A private function for handling mouse 'hovering'        var handleHover = function (e) {            // next three lines copied from jQuery.hover, ignore children onMouseOver/onMouseOut            var p = (e.type == "mouseenter" ? e.fromElement : e.toElement) || e.relatedTarget;            while (p && p != this) {                try {                    p = p.parentNode;                } catch (e) {                    p = this;                }            }            if (p == this) {                return false;            }            // copy objects to be passed into t (required for event object to be passed in IE)            var ev = jQuery.extend({}, e);            var ob = this;            // cancel hoverIntent timer if it exists            if (ob.hoverIntent_t) {                ob.hoverIntent_t = clearTimeout(ob.hoverIntent_t);            }            // if e.type == "mouseenter"            if (e.type == "mouseenter") {                // set "previous" X and Y position based on initial entry point                pX = ev.pageX;                pY = ev.pageY;                // update "current" X and Y position based on mousemove                $(ob).bind("mousemove", track);                // start polling interval (self-calling timeout) to compare mouse coordinates over time                if (ob.hoverIntent_s != 1) {                    ob.hoverIntent_t = setTimeout(function () {                        compare(ev, ob);                    }, cfg.interval);                }                // else e.type == "mouseleave"            } else {                // unbind expensive mousemove event                $(ob).unbind("mousemove", track);                // if hoverIntent state is true, then call the mouseOut function after the specified delay                if (ob.hoverIntent_s == 1) {                    ob.hoverIntent_t = setTimeout(function () {                        delay(ev, ob);                    }, cfg.timeout);                }            }        };        // bind the function to the two event listeners        return this.bind('mouseenter', handleHover).bind('mouseleave', handleHover);    };})(jQuery);;(function ($) {    $.fn.superfish = function (op) {        var sf = $.fn.superfish,            c = sf.c,            over = function () {                var $$ = $(this), menu = getMenu($$);                clearTimeout(menu.sfTimer);                $$.showSuperfishUl().siblings().hideSuperfishUl();            },            out = function () {                var $$ = $(this), menu = getMenu($$), o = sf.op;                clearTimeout(menu.sfTimer);                menu.sfTimer = setTimeout(function () {                    o.retainPath = ($.inArray($$[0], o.$path) > -1);                    $$.hideSuperfishUl();                    if (o.$path.length && $$.parents(['li.', o.hoverClass].join('')).length < 1) {                        over.call(o.$path);                    }                }, o.delay);            },            getMenu = function ($menu) {                var menu = $menu.parents(['ul.', c.menuClass, ':first'].join(''))[0];                sf.op = sf.o[menu.serial];                return menu;            },            // This next line is essential, despite the other code for arrows being removed.            // Changing the next line WILL break hoverIntent functionality. Very bad.            addArrow = function ($a) {                $a.addClass(c.anchorClass)            };        return this.each(function () {            var s = this.serial = sf.o.length;            var o = $.extend({}, sf.defaults, op);            var h = $.extend({}, sf.hoverdefaults, {over: over, out: out}, op);            o.$path = $('li.' + o.pathClass, this).slice(0, o.pathLevels).each(function () {                $(this).addClass([o.hoverClass, c.bcClass].join(' '))                    .filter('li:has(ul)').removeClass(o.pathClass);            });            sf.o[s] = sf.op = o;            $('li:has(ul)', this)[($.fn.hoverIntent && !o.disableHI) ? 'hoverIntent' : 'hover'](($.fn.hoverIntent && !o.disableHI) ? (h) : (over, out)).each(function () {            })                .not('.' + c.bcClass)                .hideSuperfishUl();            var $a = $('a', this);            $a.each(function (i) {                var $li = $a.eq(i).parents('li');                $a.eq(i).focus(function () {                    over.call($li);                }).blur(function () {                    out.call($li);                });            });            o.onInit.call(this);        }).each(function () {            var menuClasses = [c.menuClass];            $(this).addClass(menuClasses.join(' '));        });    };    var sf = $.fn.superfish;    sf.o = [];    sf.op = {};    sf.c = {        bcClass: 'sf-breadcrumb',        menuClass: 'sf-js-enabled',        anchorClass: 'sf-with-ul',    };    sf.defaults = {        hoverClass: 'sfhover',        pathClass: 'current',        pathLevels: 1,        delay: 700,        animation: {opacity: 'show', height: 'show'},        speed: 300,        disableHI: false,		// Leave as false. True disables hoverIntent detection (not good).        onInit: function () {        }, // callback functions        onBeforeShow: function () {        },        onShow: function () {        },        onHide: function () {        }    };    sf.hoverdefaults = {        sensitivity: 10,        interval: 40,        timeout: 1    };    $.fn.extend({        hideSuperfishUl: function () {            var o = sf.op,                not = (o.retainPath === true) ? o.$path : '';            o.retainPath = false;            var $ul = $(['li.', o.hoverClass].join(''), this).add(this).not(not).removeClass(o.hoverClass)                .find('>ul').hide().css('opacity', '0');            o.onHide.call($ul);            return this;        },        showSuperfishUl: function () {            var o = sf.op,                sh = sf.c,                $ul = this.addClass(o.hoverClass)                    .find('>ul:hidden').css('opacity', '1');            o.onBeforeShow.call($ul);            $ul.animate(o.animation, o.speed, function () {                o.onShow.call($ul);            });            return this;        }    });})(jQuery);// Menu customsvar $12 = jQuery.noConflict();$12(document).ready(function () {    // menu drop downs    $12('ul.dropmenu').superfish();    // tooltips    $12('.preview').SMFtooltip();    // find all nested linked images and turn off the border    $12('a.bbc_link img.bbc_img').parent().css('border', '0');});$(document).ready(function () {    $("div.panel_button").click(function () {        $("div#panel").animate({            height: "500px"        })            .animate({                height: "400px"            }, "fast");        $("div.panel_button").toggle();    });    $("div#hide_button").click(function () {        $("div#panel").animate({            height: "0px"        }, "fast");    });});